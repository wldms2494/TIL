```

function b() {
  console.log("b called!");
}

function a(another) {
  console.log("a started!");
  another();
  console.log("a ended!");
}
console.log(1);
console.log(2);
a(b);
console.log(3);
console.log(4);

```  

함수 a는 함수 b를 인자로 사용하고 있다.   
자바스크립트에서는 함수를 변수처럼 이용할 수 있음. ㅇㅅㅇ!!  
a눈 another이라는 인자를 받아서 호출하는데 여기다가 냅다 b를 집어넣었는데 돌아간다.  
함수가 함수를 인자로 받고 있고 a함수를 호출할때 b함수를 전달하는데 이를 콜백 함수라고 함ㅋ  


자 이제 비동기

비동기는 동시에 여러 작업을 해볼 수 있다.
```
function finishJob(num) {
  console.log(`${num}번 요원의 정보를 받아왔습니다.`);
}

setTimeout(finishJob, 2000, 1);
setTimeout(finishJob, 1500, 2);
setTimeout(finishJob, 1000, 3);
console.log("정보 요청을 모두 보냈습니다.");
```
여기서 우리가 생각하는 순서대로 처리를 한다면 셋타임 아웃 모두 출력 이후에 마지막 콘솔이 출력되야 한다. 하지만 그렇지 않다.  
모두들 런 동시에 각각의 일들을 실행함  
셋타임아웃은 함수 자체의 실행은 즉시 실행되고 리턴한다. 실행과 동시에 즉시 실행.  
얘가 하는 일은 작업을 예약하는 일 밖에 없다.  syntax ( function (), 초)  

결론 : 인자로 들어온 콜백함수를 예약해줌.  setTimeout에 의해 기다리는 동작은 본래의 코드 흐름과는 상관 없이 따로따로 독립적으로 돌아 감 .  
이렇게 따로 따로 독립적으로 돌아가는 작업을 비동기 작업이라고 한다.  node.js 는 파일을 다룰 때 쓰는 모든 함수들이 비동기로 구성되어 있음.  
파일을 읽으려면 우리의 하드디스크나 ssd를 동작시키는데, 이때 씨피유는 ssd가 넘 느리면 엄청 답답한데 한번에 여러개의 파일을 읽을 수 있다면 좋게찌?



그래서 비동기의 특징은, 동시에 여러 작업을 수행할 수 있으나, 흐름을 예측하기는 어렵다.  

그래서 비동기 작업 사용성 문제 !!

여러 작업을 동시에 수행할 수 있는 장점이 있지만, 의존성이 길게 이어져 있는 비동기는 나중에 노답일 수 있다. 

# PROMISE

프로미스는 비동기 작업 단위 이다 . 별 거창한건 없다. 이 작업이 진행되었을때 어떻게 처리하는지 하나의 단위로 설정해놓은 것이다.  
그래서 프로미스를 통해서 비동기 작업들을 쉽게 관리할 수 있다. !
 
 syntax : 
 
```
const promise 1 = new Promise(
(resolve, reject) => { // 비동기 작업 }
);
```

넥스트

