## 디스크 
db에서 가장 많이 사용되는 것이 디스크이다.  
대부분 교제에서는 HDD(Hard Disk Drive)를 칭하고 있지만,  
여기서 디스크는 SSD(Solid State Drive)와 HDD(Hard Disk Drive) 모두를 표현하는 말이라고 가정하겠다.  
아직은 HDD로 저장된 데이터가 많아서 해당 내용을 디비에서 배우는 것으로 보인다.  

## Disk의 Read
디스크에서 Read를 하면, 디스크에 저장됭 있는 정보가 메모리 (RAM)으로 이동된다.  
즉, 내가 SQL문으로 UPDATE문을 작성해서 SQL Server에게 요청을 하면  
해당 Attribute을 업데이트 하기 위햇는 , 해당 Attribute 정보가 메모리에 담겨야 한다.  
컴퓨터에서 수정되는 모든 정보는 폰 노이만 컴퓨터 구조상 메모리에 올라와 있어야 한다.  

## Disk 의 Write
디스크에 wirte하면, 메모리상에서 변경된 데이터를 디스크에 저장한다  
디스크와 메모리상에 주고 받는 단위를 Page라고 햇 4k 또는 8k용량이다.  
위에서 말한 Update문으로 수정되었다고 해서, 수정하고 바로 디스크로 wirte하지 않ㄴ는다.
이를 Dirty라고 표시해놓고, 수정되었다는 의미이다.  
즉 수정된 page는 Dirty Page라 부른다.  

## 데이터베이스의 병목
메모리엣 읽기 쓰기 속도와, 디스크에서 일기 쓰기 속도는 당연히 차이가 있다.  
따라서, 위의 디스크<-> 메모리 이동으로 데이터의 베이스 성능이 좌지우지 된다.  
즉, 해당 구간이 병목(bottleneck)구간이다.  

## 메모리
어짜피 디스크에서 메모리로 이동하게 될 것, 처음부터 메모리에 저장하면 안되냐는 질문을 할 수 있다.  
안되고, 안되는 이유는 메모리는 Volatile 휘발성 하기 때문이다.  
휘발유에 불을 붙이면 안되겠지만, 불을 부치고 기다렸다고 가정해보자.  
그으름만 남고 아무것도 남지 않을 것이다.  

메모리도 똑같다. 메모리 안에 있던 정보들이 평생 있을 것 같지만  
전원이 나가면 바로 사라지게 된다.  
그래서 사람의 기억력 같다고 해서 메모리라고 부르는 것으로 보인다.  
메모리는 Volatile(휘발성)하므로, 컴퓨터가 갑작스럽게 오작동 하는 경우  
메모리에 있는 정보는 모두 사라진다고 봐도 무방하다.  
두번재로 가격이 비싸다.  
비싸다는 것은, 디스크와 똑같은 용량을 구비했을 때, 비싸다는 뜻이다.  
즉, 메모리 1G와 디스크 1G를 구매한다고 가정했을때, 메모리가 훨씬 비싸다.  

## 메모리 계층
메모리는 CPU와 근접하게 있는 Cache L1, L2, L3  
그리고 위에서 말한 메모리의 Main Memory(DRAM)이 존재한다.  
대부분 메모리에 대해서 말할때, Main Memory를 말하는 것이라 이해하면 된다.  
Main Memory 하위에는 Disk와 Tape가 있다.  

## Storage 분석
HDD(Hard Disk Drive)와 SSD(Solid State Drive)등을 분석할 때,  
평가 지표로 사용되는 방법이 Random Access 와 Sequential 이다.  
Random Access 는 말 그대로, 임의 아무 공간을 골라서 접근한다고 이해하면 된다.  

Sequential 은 순찾ㄱ이라는 말이다.  
즉, 메모리를 초밥 회전 기계로 비유한다.  
초밥 회전 기계의 100개의 접시가 돌고 있는데, 시작점과 끝점을 두고 그 사이에 있는 그릇을 전부 선택하는 ㄳ이다.  
예를 들어 , 첫ㅂㄴ째 접시부터 열번째 접시를 접근한다.  

## Memory 단위
Main Memory가 Disk 의 정보를 받는 단위는 Page 단위 이다.   
주로 4K,8K이다.  

## Disk 단위
HDD를 Disk로 사용하는 경우에는 받는 단위는 Sector이다.  
이를 Dis Block이라고 표현하기도 한다.

HDD Disk 에서 Track은 육상선수가 달리는 트랙을 상상하면 된다.  
단지, 육상 선수가 도넛 모양 위에서 뛰고 있다.  
100m 짜리 도넛이고, 1 - 10m, 11 - 20m, ... 91 - 100m 로 나눠져 있다.  
이 10m 짜리 크키를 Sector라고 보면 된다.  
즉, 도넛을 10분에 1등분 시킨 것이 Sector라고 보면 된다.  
위에서 말한 100m와 10분에 1등분 등은 필자가 가정한 정보들이다.  

## Disk의 단점
Disk에서는 Head라고 데이터를 읽는 부품이 존재한다.  
위에서는 Track위에서 육상선수가 뛰고 있다고 가정을 들었다.  
해당 육상선수가 Head의 역할이라고 상상하면 된다.  

만약에, 육상선수(head)가 Track을 하나 마치고 다음 경기가 또 있다면 어떻게 해야할까?  
당연히, 다른 Track으로 이동을 해서 경기를 펼쳐야 한다.  
하지만, 경기가 한번은 서울에서 한번은 부산에서 이루어진다면 두번째 track을 달리기 위해서는   
서울에서 부산까지 가는 시간이 걸리므로 오랜 시간이 걸린다.  
Disk에서도 똑같은 문제가 일어난다.  
Disk의 Head의 위치가 가까이 있으면 빨리 읽지만, 멀리 있으면 Head의 위치를 조작하는데 오랜 시간이 걸린다.  
이는 곧장 데이터 베이스의 성능에 영향을 미친다.  

__모든 Disk Block을 접근하는데 걸리는 시간__  
모든 Disk Blcok 또는 Sector를 접근하는데 걸리는 시간은 Track을 훑는데 걸린 시간이라고 봐도 무방하다  
이는 Seek Time + Rotational Delay + Transfer Time이다.  

현재는 육상 선수에 자꾸 비유를 하다가 넘어진 내용이 있는데  
disk 구조상 head가 움직이는게 아니고 Disk가 움직인다고 하는 것이다.  
비유하자면 육상선수가 경기장에서 뛰는게 아니고 런닝머신에서 뛰는 모습이다.  
Seek Time 은 Head 이동은 완료되었는데  일고자 하는 데이터가 Head까지 도달하는데 걸리는 시간이다.  
즉, 선수는 경기장 이동을 마쳤는데 20분 후에 경기사 시작해서 기다리고 있는 것과 유사하다.  
Trasfer Time은 요청된 데이터를 Head에서 읽는데 소요되는 시간이다.  읽는 속도는 Disk Rotation 의 속도에 따라 다르다.  
즉, 선수가 Track을 완주 할 때까지의 시간이다.우사인볼트냐, 나냐에 따라 완주되는 속도가 다르다.  

<img src = "https://user-images.githubusercontent.com/80088918/147809079-88a92f06-57a2-4b53-b507-63f8df697c09.png">

__I/O를 줄이기 위한 방법___  
이러한 디스크 <-> 메모리로 이동되는 인풋 아우풋에 의해서 데이터베이스의 성능과 직관된다고 했다.  
이럿다면, I/O의 비용을 줄이기 위해서 어떻게 해야할까?  
1.물질적으로 Disk의 크기가 작은것을 사용해서 Head의 이동하는 범위를 줄인다.  
즉, Seek Time 을 줄인다.  
이는 Disk의 반지름이 작은 Disk를 사용해서 줄일 수 있다.  
2. Head가 이동하였는데, 데이터를 가져오기까지 걸리는 시간을 줄인다.
즉, Rotaional Delay Time을 줄인다.  
이는 각 HDD에서 Disk의 회전속다가 5400RPM등과 같이 나오는데, RPM이 높은 HDD를 사용하면 된다.  
RPM은 Revolution Per Minute으로 Revolution은 회전이다

3.I/O최적화  
read와 write를 Synchronous Blocking(동기) I/O를 사용하느냐, Asynchronous Blocking (비동기)I/O를 사용하느냐에 따라서 달라질 수 있다.  
이는 디비에서 말하는 Isolation Level과 관련있는듯하다.

## Dirty Page Write
메모리 상에서 데이터를 바꾸면, 해당 Page는 Dirty Page로 표시된다.  
위의 Dirty Page는 언제 Disk로 업데이트 될까?  
Flush(메모리에서 디스크로 쓰기)하는 System Call 이 있어서 해당 함수를 호출해도 되겠다.  
DB안에서는 다음의 2가지 방식으로 Flush를 수행한다.  
1. Buffer(메모리)가 Threshold(임계치)를 넘은 경우  
2. Dirty Page가 Threshod(임계치)보다 오래된 경우  
위에서는 두개가 다른 Threshold를 표현하는 것을 알아야 한다.  
즉, 2개의 별도의 변수로  표현된 임계치이다.  
첫번째는 메모리가 가득차는것을 방지해주는 임계치이고,  
두번째는 업데이트를 예를 들어 1000번 수행했는데, 해당 page가 손실되면 업데이트 1000번의 정보를 잃게 되니까  
시간이 어느정도 흐르면 디스크에 쓰기를 수행해서 해당 정보를 잃지 말자는 Threshold이다.  
위의 기능이 디비의 __Buffer Manager__ 에서 수행되는 일이다.  

## Buffer
 버퍼를 가장 단순하게 생각하면 메모리라고 봐라  
bufferManager는 Page를 일일이 관리해서 할당하고 해제하는 역할을 한다.  

## Disk의 발전
Bandwidth와 Latency의 발전 속도 차이가 있다.  
즉, Bandwidth는 파이프가 있는데 파이프를 확장해서 더 많은 정보가 흐르도록 한다고 생각하면 된다.  
Latency는 위에서 말했던 Head의 이동속도와 Rotation 속도를 올려서 방지할 수 있다.  
하지만, Bandwith는 계속해서 발전하는데 비해서 Latency는  
실제로 현실세계에서 움직이다 보니 발전하는데 개선이 많이 이루어지지 않고 있다.  
따라서 둘간의 차이로 데이터베이스에 영향이 있을 수 있다는 것을 인지해야 한다.  
