정렬 - 정렬을 하기 위해 컴퓨터에게 하는 명령



## bubble sort

두개의 인접한 원소를 비교하여 정렬하는 방식  
데이터를 '비교'하면서 찾기 때문에 '비교 정렬' 이며 정렬의 대상이 되는 데이터 외에  
추가적인 공간을 필요로 하지 않기 때문에 '제저리 정렬'이기도 하다.  
정확히는 데이터를 서로 교환하는 과정 swap에서 임시 변수를 필요로 하나,  
이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것이다.  

[1,2,4,6,9] //오름차순
[9,6,4,2,1]//내림차순


 거품 정렬의 과정 
 1) 앞에서 부터 현재 원소와 다음 원소를 비교한다
 2) 현재 원소가 다음 원소보다 크면 원소를 교환한다
 3) 다음 원소로 이동하여 해당 원소와 다음 원소를 비교한다.
  

```
[4, 6, 2, 9, 1]
-> -> -> ->
4번 돔
(배열 -1) : so
length :5

for(int i = 1 ;i<a.length ; i++ ){

}
====================================================

int []arr = {4,6,2,9,1};


[4,6,2,9,1] (5-1)번 돌림
->->->->
[4,2,6,1,9] (5-2)번 돌림
->->->
[2,4,1,6,9] (5-3)번 돌림
->->
[2,1,4,6,9] (5-4)번 돌림
->
[1,2,4,6,9] (5-5)번 돌림

arr[5]에서 4번 돌리니까 정렬이 끝났음

for(int i = 0;i<arr.length-1 ; i++) {
//여기는 round를 몇번돌리는지
}

==


for( int i = 1; i<arr.length ; i++ ) {

for(int j =0; j <arr.length-i ; j++){

//그냥 돌리는게 아니라 수를 비교하면서 swap시켜줘야 한다.

if(a[j]>a[j+1]){
swap()
}

}
}


int temp = a[i] = 3;


```

java코드
```java
public class BubbleSort {


  public static void bubble_sort(int[]a) {

    bubble_sort(a, a.length);
  }


  private static void bubble_sort(int[] a, int size) {

    //오름 차순 정렬

    //도는 횟수는 배열 크기 -1 만큼 진행됨

    for (int i = 1; i < size; i++) {

      for (int j = 0; j < size - i; i++) {

        if (a[j] > a[j + 1]) {
          swap(a, j, j + 1);
        }
      }
    }
  }

  private static void swap(int[] a, int i, int j) {
    int temp = a[i];
    a[i] = a[j];
    a[j] = temp;
  }
}

```


버블 정렬의 장점 및 단점 

장점
1) 추가적인 메모리 소비가 작다.
2) 구현이 매우 쉽다 (;;;)
3) 안장 정렬이 가능 하다.


단점
1) 다른 정렬 알고리즘에 비해 교환 과정이 많아 소비 시간이 많다.
   1) 